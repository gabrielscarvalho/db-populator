# DB Populator
Make it easy to populate your test database, creating inserts based on a simple json:

    't_customer': {
         'id': { 'type':  'int', val: id.getNext('t_customer') },
         'name': { type:  'string', val: Random.fromList(['John', 'Paul', 'Suzan', 'Mark']) },
    },
    
    't_address': {
       'id': { 'type':  'int', val: id.getNext('t_address') },
       'customer_id': { 'type':  'int', val: id.getCurrent('t_customer') },
       'street': { type:  'string', val: Random.fromList(['St. Abc', 'St. Cde']) },
       'number': { type:  'int', val: Random.number({ min:  1, max:  150 }) },
       'is_main_address': { type:  'bool', val: Random.fromList([true, false]) }
    }

Containing: table, column, type and value.
After that, you can create your data, calling:

    const  customer  = insert('t_customer', { 'email':  'john120@gmail.com' })
    insert('t_address', { 'street':  'delivery address' });
    insert('t_address', { 'street':  'invoice address', customer_id: customer.id });
    insert.printSQLs();

And that's all! It will return your inserts.
## About the json
It must contain the structure:

    {
    <table_name> : {
       <column_name or easier identifier> :  { type: <type_of_column>, val: <raw_or_fn()>, columnName: <optional String>  }
    }
Example:

    {
     't_customer' : {
         'id': { 'type':  'int', val:  id.getNext('t_customer'), column: 'customer_id' },
         'name' : { type: 'string', val: 'John', columnName: 'customer_name' },
         'birth_date': { type: 'date', val: Random.date({ minYear:  1970, maxYear:  2010 })} 
      }
    }
    
In this example, if we execute:

    insert('t_customer', {name: 'Mary'}); //  {customer_id: 1, customer_name: 'Mary', birth_date: 1996-03-11}
    insert('t_customer', {}); //  {customer_id: 2, customer_name: 'John', birth_date: 1997-01-06}
    insert('t_customer', {id: 5}); //  {customer_id: 5, customer_name: 'John', birth_date: 1990-10-01} 
Notice that:

 - if you do not inform the field value on insert method,  it will take from the json.
 - id.getNext('t_customer') helps you to get the next id easily, but you still can force the next value.
 - the field "val" must be the literal value or a function that will return it.
	 - In the example of Random.date, it returns:

-	


        Random.date = (params) => {
            return () => {
               return formatDate(randomDate, params)
            }
       } 

## Types

Types are pre-defined in order to populate the values into the insert. 
You can see them at: [ValueStrategyParser](https://github.com/gabrielscarvalho/db-populator/blob/master/lib/value-strategy-parser.js "ValueStrategyParser")

At this moment, you can use:


|type| effect on queries| 
| ------------ | ------------ |
|string| will put quotes at the variable|
|int| will parse to int |
|float| will parse to float|
| datetime| return a string datetime 'YYYY-MM-DDTHH:mm:ss'|
| date | return a string date 'YYYY-MM-DD'|
|raw| will just add the value the same way it is. You can use this for functions, for example, NOW()|

You are able to add new types if required.

```javascript
const id = require('db-populator/lib/id');
const GenericSQLBuilder = require('db-populator/db/GenericSQLBuilder');
const ValueStrategyParser = require('db-populator/lib/value-strategy-parser');

const valueStategyParser = new ValueStrategyParser("'");// the unified quote symbol
valueStrategyParser.addParser('my-timestamp', (val) =>  {
  //format val as you wish
  return formatedValToInsert;
});

configure(new GenericSQLBuilder(dbStructure(id, valueStrategyParser)));

```

## Basic Example

Check the folder: [example](https://github.com/gabrielscarvalho/db-populator/tree/master/example "example")
Inside of it, you will find 3 files:
* db-structure: defines the db rules
* insert: configure the insert 
* index.js: run your command.

## insert(string tableName, object extraData)
Creates a new sql insert and save it.
Keep in mind this table:

    {
     't_customer' : {
         'id': { 'type':  'int', val:  id.getNext('t_customer'), column: 'customer_id' },
         'name' : { type: 'string', val: 'John', columnName: 'customer_name' }
      }
    }

If you call insert, it will return your filled object.

    const customer = insert('t_customer', { name: 'Mary' })
    console.log('just created: ', customer.name)
You can use it to make cascade inserts:

    const customer = insert('t_customer', { name: 'Mary' })
    insert('t_address', { customer_id: customer.id})

**Note**: the object returned will have the same props as your table is mapped.
 That is the reason you can use *customer.id* on the second insert, instead of *customer.customer_id* (that is the real column name)

### insert.printSQLs()
Print all SQLs saved until that moment.
### insert.printData()
Prints all objects that you have created
### insert.printCompleteData()
Prints all objects that will be used to create your inserts. As the name says, is more complete.




