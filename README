# DB Populator
Make it easy to populate your test database, creating inserts based on a simple json:

    't_customer': {
         'id': { 'type':  'int', val: id.getNext('t_customer') },
         'name': { type:  'string', val: Random.fromList(['John', 'Paul', 'Suzan', 'Mark']) },
    },
    
    't_address': {
       'id': { 'type':  'int', val: id.getNext('t_address') },
       'customer_id': { 'type':  'int', val: id.getCurrent('t_customer') },
       'street': { type:  'string', val: Random.fromList(['St. Abc', 'St. Cde']) },
       'number': { type:  'int', val: Random.number({ min:  1, max:  150 }) },
       'is_main_address': { type:  'bool', val: Random.fromList([true, false]) }
    }

Containing: table, column, type and value.
After that, you can create your data, calling:

    const  customer  = insert('t_customer', { 'email':  'john120@gmail.com' })
    insert('t_address', { 'street':  'delivery address' });
    insert('t_address', { 'street':  'invoice address', customer_id: customer.id });
    insert.printSQLs();

And that's all! It will return your inserts.
## About the json
It must contain the structure:

    {
    <table_name> : {
       <column_name or easier identifier> :  { type: <type_of_column>, val: <raw_or_fn()>, columnName: <optional String>  }
    }
Example:

    {
     't_customer' : {
         'id': { 'type':  'int', val:  id.getNext('t_customer'), column: 'customer_id' },
         'name' : { type: 'string', val: 'John', columnName: 'customer_name' },
         'birth_date': { type: 'date', val: Random.date({ minYear:  1970, maxYear:  2010 })} 
      }
    }
    
In this example, if we execute:

    insert('t_customer', {name: 'Mary'}); //  {customer_id: 1, customer_name: 'Mary', birth_date: 1996-03-11}
    insert('t_customer', {}); //  {customer_id: 2, customer_name: 'John', birth_date: 1997-01-06}
    insert('t_customer', {id: 5}); //  {customer_id: 5, customer_name: 'John', birth_date: 1990-10-01} 
Notice that:

 - if you do not inform the field value on insert method,  it will take from the json.
 - id.getNext('t_customer') helps you to get the next id easily, but you still can force the next value.
 - the field "val" must be the literal value or a function that will return it.
	 - In the example of Random.date, it returns:

-	


        Random.date = (params) => {
            return () => {
               return formatDate(randomDate, params)
            }
       } 

## Docs

## Basic Structure

Here you can see the most clear scenario possible.
 - Choose Db parser
 - Configure Initial IDs
 - Creates your db structure
 - Creates your inserts

   

        const  configure  =  require('./lib/insert');
        const  ID  =  require('./lib/id');
        const  PostgreSQL  =  require('./db/postgresql');
        
        const  initialIds  = {
        't_customer':  0,
        't_address':  0,
        };
        const  id  =  new  ID(initialIds);
        
        const dbStructure = {
    	    't_customer': {
    			'id': { 'type':  'int', val: id.getNext('t_customer') },
    			'name': { type:  'string', val: Random.fromList(['John', 'Paul', 'Suzan', 'Mark']) },
    		},
    		't_address': {
    			'id': { 'type':  'int', val: id.getNext('t_address') },
    			'customer_id': { 'type':  'int', val: id.getCurrent('t_customer') },
    		}
    	};
    	
        const  insert  =  configure(new  PostgreSQL(dbStructure));
        
        insert('t_customer', { 'email':  'john120@gmail.com' })
        const  address1  =  insert('t_address', { 'street':  'delivery address' });
        insert.printSQLs();


## insert(string tableName, object extraData)
Creates a new sql insert and save it.
Keep in mind this table:

    {
     't_customer' : {
         'id': { 'type':  'int', val:  id.getNext('t_customer'), column: 'customer_id' },
         'name' : { type: 'string', val: 'John', columnName: 'customer_name' }
      }
    }

If you call insert, it will return your filled object.

    const customer = insert('t_customer', { name: 'Mary' })
    console.log('just created: ', customer.name)
You can use it to make cascade inserts:

    const customer = insert('t_customer', { name: 'Mary' })
    insert('t_address', { customer_id: customer.id})

**Note**: the object returned will have the same props as your table is mapped.
 That is the reason you can use *customer.id* on the second insert, instead of *customer.customer_id* (that is the real column name)

### insert.printSQLs()
Print all SQLs saved until that moment.
### insert.printData()
Prints all objects that you have created
### insert.printCompleteData()
Prints all objects that will be used to create your inserts. As the name says, is more complete.




